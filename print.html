<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rusty Engine Tutorial</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00-welcome.html">Welcome to Rusty Engine!</a></li><li class="chapter-item expanded affix "><a href="02-quick-start.html">Quick Start Example</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="05-config.html"><strong aria-hidden="true">1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="10-assets.html"><strong aria-hidden="true">2.</strong> Asset Pack</a></li><li class="chapter-item expanded "><a href="15-init.html"><strong aria-hidden="true">3.</strong> Engine Initialization</a></li><li class="chapter-item expanded "><a href="20-game-state.html"><strong aria-hidden="true">4.</strong> Game State</a></li><li class="chapter-item expanded "><a href="25-game-logic-function.html"><strong aria-hidden="true">5.</strong> Game Logic Function</a></li><li class="chapter-item expanded "><a href="50-sprite.html"><strong aria-hidden="true">6.</strong> Sprite</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="55-sprite-creation.html"><strong aria-hidden="true">6.1.</strong> Creation</a></li><li class="chapter-item expanded "><a href="60-sprite-placement.html"><strong aria-hidden="true">6.2.</strong> Placement</a></li><li class="chapter-item expanded "><a href="65-sprite-collider.html"><strong aria-hidden="true">6.3.</strong> Collider</a></li></ol></li><li class="chapter-item expanded "><a href="100-input.html"><strong aria-hidden="true">7.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="105-keyboard-state.html"><strong aria-hidden="true">7.1.</strong> Keyboard State</a></li><li class="chapter-item expanded "><a href="110-keyboard-events.html"><strong aria-hidden="true">7.2.</strong> Keyboard Events</a></li><li class="chapter-item expanded "><a href="115-mouse-state.html"><strong aria-hidden="true">7.3.</strong> Mouse State</a></li><li class="chapter-item expanded "><a href="120-mouse-events.html"><strong aria-hidden="true">7.4.</strong> Mouse Events</a></li></ol></li><li class="chapter-item expanded "><a href="150-text.html"><strong aria-hidden="true">8.</strong> Text</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="155-text-creation.html"><strong aria-hidden="true">8.1.</strong> Creation</a></li><li class="chapter-item expanded "><a href="160-text-attributes.html"><strong aria-hidden="true">8.2.</strong> Value, Font &amp; Font Size</a></li><li class="chapter-item expanded "><a href="165-text-placement.html"><strong aria-hidden="true">8.3.</strong> Placement</a></li></ol></li><li class="chapter-item expanded "><a href="200-audio.html"><strong aria-hidden="true">9.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="205-music.html"><strong aria-hidden="true">9.1.</strong> Music</a></li><li class="chapter-item expanded "><a href="210-sfx.html"><strong aria-hidden="true">9.2.</strong> Sound Effects</a></li></ol></li><li class="chapter-item expanded "><a href="250-timer.html"><strong aria-hidden="true">10.</strong> Timer</a></li><li class="chapter-item expanded "><a href="400-engine.html"><strong aria-hidden="true">11.</strong> Engine</a></li><li class="chapter-item expanded "><a href="450-game.html"><strong aria-hidden="true">12.</strong> Game</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rusty Engine Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-rusty-engine"><a class="header" href="#welcome-to-rusty-engine">Welcome to Rusty Engine!</a></h1>
<p>Rusty Engine is a simple, 2D game engine for those who are learning Rust. Create simple game prototypes using straightforward Rust code without needing to learning difficult game engine concepts! It works on macOS, Linux, and Windows. Rusty Engine is a simplification wrapper over <a href="https://bevyengine.org/">Bevy</a>, which I encourage you to use directly for more serious game engine needs.</p>
<p>The following courses use Rusty Engine in their curriculum:</p>
<ul>
<li><a href="https://www.udemy.com/course/ultimate-rust-2/?referralCode=8ED694EBE5637F954414">Ultimate Rust 2: Intermediate Concepts</a> on Udemy (the sequel to <a href="https://www.udemy.com/course/ultimate-rust-crash-course/?referralCode=AF30FAD8C6CCCC2C94F0">Ultimate Rust Crash Course</a>)</li>
<li><a href="https://agileperception.com">Rust in 3 Weeks</a> conducted live on O'Reilly Online approximately once each quarter.</li>
</ul>
<h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This tutorial will walk you through all the major features of the engine. For more details, see also:</p>
<ul>
<li><a href="https://github.com/CleanCut/rusty_engine/tree/main/scenarios">Game Scenarios</a></li>
<li><a href="https://docs.rs/rusty_engine/latest/rusty_engine/">The Rusty Engine Documentation</a></li>
<li><a href="https://github.com/CleanCut/rusty_engine/tree/main/examples">The <code>examples</code> directory in the repository</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-example"><a class="header" href="#quick-start-example">Quick Start Example</a></h1>
<ul>
<li>Create a new Rust project and add <code>rusty_engine</code> as a dependency (see the <a href="05-config.html">Configuration</a> page for more details)</li>
</ul>
<pre><code class="language-toml"># In your [dependencies] section of Cargo.toml
rusty_engine = &quot;5.0.3&quot;
</code></pre>
<ul>
<li>Download the Asset Pack to your project (see the <a href="10-assets.html">Asset Pack</a> page for more details).</li>
</ul>
<pre><code class="language-shell">curl -L https://github.com/CleanCut/rusty_engine/archive/refs/heads/main.tar.gz | tar -zxv --strip-components=1 rusty_engine-main/assets
</code></pre>
<ul>
<li>Write your game:</li>
</ul>
<pre><code class="language-rust ignore">// in src/main.rs
 use rusty_engine::prelude::*;

 // Define a struct to hold custom data for your game (it can be a lot more complicated than this one!)
 struct GameState {
     health: i32,
 }

 fn main() {
     // Create a game
     let mut game = Game::new();

     // Set up your game. `Game` exposes all of the methods (but not fields) of `Engine`
     let sprite = game.add_sprite(&quot;player&quot;, SpritePreset::RacingCarBlue);
     sprite.scale = 2.0;

     game.audio_manager.play_music(MusicPreset::Classy8Bit, 1.0);

     // Add one or more functions with logic for your game. When the game is run, the logic
     // functions will run in the order they were added.
     game.add_logic(game_logic);

     // Run the game, with an initial state
     game.run(GameState { health: 100 });
 }

 // Your game logic functions can be named anything, but the first parameter is always a
 // `&amp;mut Engine`, and the second parameter is a mutable reference to your custom game
 // state struct (`&amp;mut GameState` in this case). The function returns a `bool`.
 //
 // This function will be run once each frame.
 fn game_logic(engine: &amp;mut Engine, game_state: &amp;mut GameState) {
     // The `Engine` contains all sorts of built-in goodies.
     // Get access to the player sprite...
     let player = engine.sprites.get_mut(&quot;player&quot;).unwrap();
     // Rotate the player...
     player.rotation += std::f32::consts::PI * engine.delta_f32;
     // Damage the player if it is out of bounds...
     if player.translation.x &gt; 100.0 {
         game_state.health -= 1;
     }
 }
</code></pre>
<ul>
<li>Run your game with <code>cargo run --release</code>.  Don't forget the <code>--release</code>!</li>
</ul>
<img width="1348" alt="example screenshot" src="https://user-images.githubusercontent.com/5838512/146858022-1d91c7f4-8b21-4f85-a72a-c4b93edcabc6.png">
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<ul>
<li>Create a new Rust project</li>
<li>In your <code>Cargo.toml</code> file, add <code>rusty_engine</code> to your <code>[dependencies]</code> section:</li>
</ul>
<pre><code class="language-toml"># In your [dependencies] section of Cargo.toml
rusty_engine = &quot;5.0.3&quot;
</code></pre>
<h3 id="optional-make-dev-profile-act-like-release"><a class="header" href="#optional-make-dev-profile-act-like-release">(Optional) Make <code>dev</code> profile act like <code>release</code></a></h3>
<p>If you don't want to have remember to constantly add <code>--release</code> to your <code>cargo build</code> and <code>cargo run</code> commands, you can add this config section to your <code>Cargo.toml</code> to make your <code>dev</code> profile act like the <code>release</code> profile:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 3
debug = false
debug-assertions = false
overflow-checks = false
incremental = false
codegen-units = 16
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-pack"><a class="header" href="#asset-pack">Asset Pack</a></h1>
<p>Rusty Engine assumes the asset pack is present, so you MUST download the asset pack.</p>
<p>Here are three different ways to download the assets (pick any of them--it should end up the same in the end):</p>
<ul>
<li>RECOMMENDED: On a posix compatible shells run this command inside your project directory:</li>
</ul>
<pre><code class="language-shell">curl -L https://github.com/CleanCut/rusty_engine/archive/refs/heads/main.tar.gz | tar -zxv --strip-components=1 rusty_engine-main/assets
</code></pre>
<ul>
<li>OR, clone the <code>rusty_engine</code> repository and copy/move the <code>assets/</code> directory over to your own project</li>
<li>OR, download a <a href="https://github.com/CleanCut/rusty_engine/archive/refs/heads/main.zip">zip file</a> or <a href="https://github.com/CleanCut/rusty_engine/archive/refs/heads/main.tar.gz">tarball</a> of the <code>rusty_engine</code> repository, extract it, and copy/move the <code>assets/</code> directory over to your own project.</li>
</ul>
<h2 id="asset-directory-structure"><a class="header" href="#asset-directory-structure">Asset Directory Structure</a></h2>
<p>All assets reside inside an <code>assets/</code> directory at the top folder of your Rust project (in the same directory as <code>Cargo.toml</code>).</p>
<p>The structure looks like this:</p>
<pre><code class="language-text">assets
├── audio
│   ├── music
│   └── sfx
├── fonts
└── sprite
    ├── racing
    └── rolling
</code></pre>
<p>You can organize your own custom files wherever you like, but the asset pack will always be organized like this:</p>
<ul>
<li>Audio files in <code>assets/audio</code>. The asset pack divides sounds into <code>music</code> and <code>sfx</code> subdirectories.</li>
<li>Font files in <code>assets/font</code>.</li>
<li>Sprites (images and colliders) in <code>assets/sprite</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine-initialization"><a class="header" href="#engine-initialization">Engine Initialization</a></h1>
<p>Rusty Engine has a prelude which you should import in <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">use rusty_engine::prelude::*;
</code></pre>
<p>You should usually define a <a href="20-game-state.html"><code>GameState</code></a> struct (which we'll go over in the <a href="20-game-state.html">game state section</a>). This will be a struct that you store your game-specific data in. Things like high score, player name, health left, etc.</p>
<pre><code class="language-rust ignore">use rusty_engine::prelude::*;

struct GameState {
    health_left: i32,
}

fn main() {
    // ...
}
</code></pre>
<p>Create a new <code>Game</code> struct in your <code>main</code> function and assign it to a mutable variable, usually called <code>game</code>.</p>
<pre><code class="language-rust ignore">fn main() {
    let mut game = Game::new();
    // ...
</code></pre>
<p>Use your <code>Game</code> instance to set up your game and register logic functions to run each frame.</p>
<p>At the end of main you will run your game with <code>Game::run()</code>. The <code>run</code> method takes an initial game state. If you didn't define a game state struct, then just give it a unit struct <code>()</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    // ...
    game.run(());
}
</code></pre>
<p>If you did define a game state struct (we'll assume you named it <code>GameState</code>), then pass <code>run</code> a value of that type:</p>
<pre><code class="language-rust ignore">fn main() {
    // ...
    game.run(GameState { health_left: 42 });
}
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>If you put it all together, it looks like this. This example will run and create an empty window, but won't <em>do</em> anything, yet.</p>
<pre><code class="language-rust ignore">use rusty_engine::prelude::*;

struct GameState {
    health_left: i32,
}

fn main() {
    let mut game = Game::new();

    // get your game stuff ready here

    game.run(GameState { health_left: 42 });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-state"><a class="header" href="#game-state">Game State</a></h1>
<p>You will need somewhere to store data for your game that is not part of the engine but that you need access to for more than a single frame. That somewhere is your <em>game state struct</em>.  You provide a struct to use for your own game state. Within that struct, you can store just about anything. Some examples of things you may want to put in your game state:</p>
<ul>
<li>Player attributes (name, color, health, energy, money, etc.)</li>
<li>Game attributes (score, day, turn, etc.)</li>
<li>Timers for animation, spawning events, etc.</li>
<li>Collections of sprite labels to iterate through (perhaps a vector of labels of all the enemy sprites, or a vector of widgets to animate, or...whatever)</li>
<li>Collections of text labels to iterate through and update (maybe text representing current health is placed above your player)</li>
<li>Anything else that needs to persist across frames that isn't already stored in the engine</li>
</ul>
<p>You can name your game state struct whatever you want, but since there can only ever be one game state type, we suggest you call it <code>GameState</code> as we will in this tutorial.</p>
<p>Here is an example of a game state you might define for a simple game which keeps track of a current score and a high score, the labels of enemies which need to move around, and a timer for when to spawn a new enemy.</p>
<pre><code class="language-rust ignore">struct GameState {
    high_score: u32,
    current_score: u32,
    enemy_labels: Vec&lt;String&gt;,
    spawn_timer: Timer,
}
</code></pre>
<p>When you start your game, you will need to pass it an initial value of the game state.  You will receive a mutable reference to this game state value in your logic function(s) each frame.</p>
<pre><code class="language-rust ignore">fn main() {
    // ...
    let game_state = GameState {
        high_score: 2345,
        current_score: 0,
        enemy_labels: Vec::new(),
        spawn_timer: Timer::from_seconds(10.0, false),
    };
    game.run(game_state);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-logic-function"><a class="header" href="#game-logic-function">Game Logic Function</a></h1>
<p>A game is divided up into <em>frames</em>. A <em>frame</em> is one run through your game logic to produce a new image to display on the screen. On most hardware you will usually get about 60 frames each second.  Rusty Engine tries to run your game logic function(s) once each frame.</p>
<p>A game logic function definition looks like this:</p>
<pre><code class="language-rust ignore">fn game_logic(engine: &amp;mut Engine, game_state: &amp;mut GameState) {
    // your actual game logic goes here
}
</code></pre>
<p>If you passed in a unit struct for your game state, then use a unit struct in your logic function definition:</p>
<pre><code class="language-rust ignore">fn game_logic(engine: &amp;mut Engine, game_state: &amp;mut ()) {
    // logic...without any state to look at.
}
</code></pre>
<p>The function may be named anything you want. We used <code>game_logic</code> in the example above, which is the conventional name if you only have one. However, if you use more than one game logic function, each will need to have a unique name.</p>
<p>You need to &quot;add&quot; your game logic functions to Rusty Engine by calling <code>Game::add_logic</code> in your <code>main</code> function:</p>
<pre><code class="language-rust ignore">game.add_logic(game_logic);
</code></pre>
<p>You can add multiple game logic functions, which will always run in the order they were added. For example, this game will always run the <code>menu_logic</code> function first, and then the <code>game_logic</code>.</p>
<pre><code class="language-rust ignore">game.add_logic(menu_logic);
game.add_logic(game_logic);
</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Here's an example game logic function using the game state from the <a href="20-game-state.html">game state section</a>. It simply increments the score and outputs that score to the console once per frame.</p>
<pre><code class="language-rust ignore">use rusty_engine::prelude::*;

struct GameState {
    high_score: u32,
    current_score: u32,
    enemy_labels: Vec&lt;String&gt;,
    spawn_timer: Timer,
}

fn main() {
    let mut game = Game::new();
    let game_state = GameState {
        high_score: 2345,
        current_score: 0,
        enemy_labels: Vec::new(),
        spawn_timer: Timer::from_seconds(10.0, false),
    };
    game.add_logic(game_logic); // Don't forget to add the logic function to the game!
    game.run(game_state);
}

fn game_logic(engine: &amp;mut Engine, game_state: &amp;mut GameState) {
    game_state.current_score += 1;
    println!(&quot;Current score: {}&quot;, game_state.current_score);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite"><a class="header" href="#sprite">Sprite</a></h1>
<p>A <em>sprite</em> in Rusty Engine is a 2D image, how it is placed on the screen (translation, rotation, scale, and layer), its collider, and other associated metadata. You will use sprites for all the graphics in your game. Many sprites will represent some <em>thing</em>. For example, a race car sprite may represent your player character in your game.</p>
<p><img src="https://github.com/CleanCut/rusty_engine/raw/main/assets/sprite/racing/car_green.png" alt="green race car sprite" /></p>
<p>A barrel sprite may represent an obstacle, an enemy, or maybe it's just part of the background. It's up to you to decide how to treat the sprites.</p>
<p><img src="https://github.com/CleanCut/rusty_engine/raw/main/assets/sprite/racing/barrel_blue.png" alt="blue barrel sprite" /></p>
<p><a href="55-sprite-creation.html">Next: Sprite Creation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite-creation"><a class="header" href="#sprite-creation">Sprite Creation</a></h1>
<p>Sprites are created through the <a href="400-engine.html"><code>Engine</code></a>.  Since <code>Game</code> implements <code>DerefMut&lt;Engine&gt;</code>, you can also call all of <code>Engine</code>'s creation methods through <code>Game</code> in your <code>main()</code> function. In either case, it looks something like this when you create a sprite with a preset:</p>
<pre><code class="language-rust ignored">// Through your `Game` in `main()`
let _ = game.add_sprite(&quot;my_player&quot;, SpritePreset::RacingCarBlue);

// Or later in a game logic function
let _ = engine.add_sprite(&quot;my_player&quot;, SpritePreset::RacingCarBlue);
</code></pre>
<p>All sprites in the asset pack have a &quot;preset&quot;, which is just a fancy <code>enum</code> that makes it easy for you as a user to select one of sprite image files. You could also specify the image filepath, relative to the <code>assets/sprite</code> directory, which you would do if you add your own images.  For example, the full filepath of the blue racing car is <code>assets/sprite/racing/car_blue.png</code>, so to create it by filepath you would do:</p>
<pre><code class="language-rust ignored">let _ = engine.add_sprite(&quot;my_player&quot;, &quot;racing/car_blue.png&quot;);
</code></pre>
<p><code>add_sprite</code> returns a mutable reference to a <code>Sprite</code> (<code>&amp;mut Sprite</code>). Since it will emit a warning to silently ignore the reference, you should explicitly ignore it if you are not going to use it by doing <code>let _ = ...</code> as in the examples above. However, most of the time you will want to use the mutable reference to immediately adjust your sprite.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite-placement"><a class="header" href="#sprite-placement">Sprite Placement</a></h1>
<p>There are four different fields you can use to position and size your sprite:</p>
<h3 id="translation"><a class="header" href="#translation">Translation</a></h3>
<p><code>Sprite.translation</code> is a <a href="https://docs.rs/glam/latest/glam/f32/struct.Vec2.html"><code>Vec2</code></a> containing the X and Y coordinates of your sprite's position on the screen. The coordinate system works just like it does in math class. <code>(0.0, 0.0)</code> is in the center of the screen. Positive X goes to the right side of the screen. Positive Y goes to the top of the screen. Every increment of <code>1.0</code> is one logical pixel on the screen. Hi-DPI screens may have more than one physical pixel per logical pixel. See the <a href="400-engine.html"><code>Engine</code></a> section for details on how to check the logical pixel dimensions of your window.</p>
<h3 id="rotation"><a class="header" href="#rotation">Rotation</a></h3>
<p><code>Sprite.rotation</code> is an <code>f32</code> representing the angle in radians from the positive X axis. In other words, a rotation of <code>0.0</code> is facing to the right, so custom images you want to use in Rusty Engine should also be &quot;facing&quot; to the right in their raw form (whatever &quot;to the right&quot; means is up to you). <code>2 * PI</code> brings you in a full circle, so <code>0.5 * PI</code> is &quot;up&quot;, <code>PI</code> is &quot;left&quot;, and <code>1.5 * PI</code> is &quot;down&quot;. There are a bunch of helpful constants defined for cardinal directions if you don't want to remember the numerical value yourself.</p>
<h3 id="scale"><a class="header" href="#scale">Scale</a></h3>
<p><code>Sprite.scale</code> is an <code>f32</code>. <code>1.0</code> means matching a pixel of the source image to a pixel on the screen. <code>2.0</code> makes the image twice as wide and tall, etc.</p>
<h3 id="layer"><a class="header" href="#layer">Layer</a></h3>
<p><code>Sprite.layer</code> is an <code>f32</code> that affects what sprite or text is &quot;on top&quot; of another sprite or text when they overlap. <code>0.0</code> is the default and &quot;bottom&quot; layer, and <code>999.0</code> is the &quot;top&quot; layer. The order of sprites or text on the same layer is random and unstable (can change frame to frame), so you should make sure that sprites and text that will overlap are on different layers. A good practice is to choose a few layers and assign them to constants. For example:</p>
<pre><code class="language-rust ignored">const BACKGROUND_LAYER: f32 = 0.0;
const CHARACTER_LAYER: f32 = 1.0;
const EFFECTS_LAYER: f32 = 2.0;
const UI_BOTTOM_LAYER: f32 = 3.0;
const UI_TOP_LAYER: f32 = 4.0;
</code></pre>
<h3 id="adjusting-your-newly-created-sprite"><a class="header" href="#adjusting-your-newly-created-sprite">Adjusting your newly-created sprite</a></h3>
<p>When you create a sprite, you get a mutable reference to the newly-created sprite that you can use to adjust it.</p>
<pre><code class="language-rust ignored">let player = engine.add_sprite(&quot;my_player&quot;, SpritePreset::RacingCarBlue);
player.translation = Vec2::new(200.0, 100.0); // Move the car up and to the right
player.rotation = UP; // UP is one of the built-in constants you can use
player.scale = 2.5; // It's a BIG car!
player.layer = CHARACTER_LAYER; // as in previous code snippet
</code></pre>
<p>The <code>Vec2</code> type used for the <code>translation</code> field is from <code>glam</code>, and has <a href="https://docs.rs/glam/latest/glam/f32/struct.Vec2.html">its own documentation</a> you can read up on if you're interested.  The thing you'll probably use the most are its <code>x</code> and <code>y</code> fields:</p>
<pre><code class="language-rust ignored">player.translation.x += 45.0 * engine.delta_f32;
player.translation.y -= 10.0 * engine.delta_f32;
</code></pre>
<p>NOTE: If you want to adjust your sprite smoothly, you will need to multiply it by the frame's delta value. See the <a href="400-engine.html"><code>Engine</code></a> section for more details.</p>
<h3 id="adjusting-an-existing-sprite"><a class="header" href="#adjusting-an-existing-sprite">Adjusting an existing sprite</a></h3>
<p>To adjust a sprite which already exists, you need to get a mutable reference to it.  This is where that &quot;label&quot; comes in.  The <code>Engine.sprites</code> field is a hash map of labels to sprites. You get a mutable reference to a sprite with the <code>HashMap::get_mut</code> method:</p>
<pre><code class="language-rust ignored">// Be careful with unwrap()! If the entry isn't there, this will crash your game.
let player_reference = engine.sprites.get_mut(&quot;my_player&quot;).unwrap();
player_reference.rotation += TURN_SPEED_PER_SEC * engine.delta_f32;
</code></pre>
<h3 id="deleting-a-sprite"><a class="header" href="#deleting-a-sprite">Deleting a sprite</a></h3>
<p>To delete a sprite, simply remove it from the <code>Engine.sprites</code> hash map.</p>
<pre><code class="language-rust ignored">engine.sprites.remove(&quot;my_player&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite-collisions"><a class="header" href="#sprite-collisions">Sprite Collisions</a></h1>
<p>Rusty Engine has a basic system for detecting collisions between sprites. When two sprites with collision enabled begin or end overlapping, a <a href="https://docs.rs/rusty_engine/latest/rusty_engine/physics/struct.CollisionEvent.html"><code>CollisionEvent</code></a> will be produced. By default, collisions are disabled on sprites, so you need to set the sprite's <code>collision</code> field to <code>true</code> if you want it to emit <code>CollisionEvent</code>s.</p>
<h3 id="processing-collision-events"><a class="header" href="#processing-collision-events">Processing collision events</a></h3>
<p>Your game logic should process collision events each frame. Collision events which you don't handle are discarded at the end of each frame. Collision events are accessed through the <code>Engine.collision_events</code> vector.</p>
<p>Each <code>CollisionEvent</code> consists of a <code>CollisionState</code> (an enum of either <code>Begin</code> or <code>End</code>) and a <code>CollisionPair</code>, which is a tuple of the labels of the two sprites involved in the collision. It is up to you to figure out what to do with the information that a collision occurred.</p>
<pre><code class="language-rust ignored">for event in engine.collision_events.drain(..) {
    match event.state {
        CollisionState::Begin =&gt; {
            println!(&quot;{} and {} collided!&quot;, event.pair.0, event.pair.1);
        }
        CollisionState::End =&gt; {
            println!(&quot;{} and {} are no longer colliding.&quot;, event.pair.0, event.pair.1);
        }
    }
}
</code></pre>
<h3 id="colliders"><a class="header" href="#colliders">Colliders</a></h3>
<p>Colliders are convex polygons that are used to detect if a collision has occurred between two sprites. Colliders will be rendered as polygons with white lines on the screen if <code>Engine.show_colliders</code> is set to <code>true</code>.</p>
<p>Colliders are stored in files with the same filename and path as the image file the sprite uses, but with a <code>.collider</code> extension. If a valid collider file exists, it will be loaded automatically. </p>
<h3 id="creating-colliders"><a class="header" href="#creating-colliders">Creating colliders</a></h3>
<p>All of the sprite presets in the game already have colliders, so you only have to set the <code>collision</code> field to true for sprite presets.</p>
<p>If you create a new sprite using your own image, and you want it to produce <code>CollisionEvent</code>s, then you need to create a collider for that sprite.</p>
<p>Creating colliders from scratch is quite tedius, so there is an &quot;example&quot; program called <code>collider</code> that you can use to create a collider! To run <code>collider</code>, clone the <a href="https://github.com/CleanCut/rusty_engine/"><code>rusty_engine</code></a> repository, place your image file in the <code>assets</code> directory (let's call it <code>db.png</code>), and then run:</p>
<pre><code class="language-text"># Install the collider example (you only need to do this once)
$ cargo install rusty_engine --example collider

# Inside your project, run the collider example
$ collider assets/db.png
</code></pre>
<p>Then follow the example's console instructions to create (or re-create) a collider and write it to a file.</p>
<img width="1392" alt="Screen Shot 2021-12-26 at 10 45 40 PM" src="https://user-images.githubusercontent.com/5838512/147438683-c8af2db7-66dd-463c-a269-d03f37869496.png">
<p>Once you have a good collider created, copy (or move) both your image and <code>.collider</code> files to your own project, under the <code>assets/</code> directory somewhere, and then <a href="55-sprite-creation.html">add the sprite to your game</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<p>For games to be interactive, you need to process input from the user! Rusty Engine handles keyboard and mouse input.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-state"><a class="header" href="#keyboard-state">Keyboard State</a></h1>
<p>You can think of keyboard <em>state</em> as a snapshot of exactly which keys are pressed (or not) at the start of the frame. Keyboard state is best for interactive things like character movement.  If you need to process every single keystroke (like when entering text), check out the <a href="110-keyboard-event.html">Keyboard Event</a> section instead.</p>
<p>The <code>Engine.keyboard_state</code> field is a struct through which you query the state of the key(s) you are interested in.</p>
<p>Rusty Engine exposes <a href="https://bevyengine.org/">Bevy</a>'s <a href="https://docs.rs/bevy/latest/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a> enum directly. See <a href="https://docs.rs/bevy/latest/bevy/input/keyboard/enum.KeyCode.html">the <code>KeyCode</code> documentation</a> for all the possible key variants.</p>
<h3 id="pressed--released"><a class="header" href="#pressed--released">Pressed / Released</a></h3>
<p>Use the <code>pressed</code> method see if a single key is currently pressed or not:</p>
<pre><code class="language-rust ignored">if engine.keyboard_state.pressed(KeyCode::Enter) {
    // do stuff every frame that the key is still pressed 
}
</code></pre>
<p>If a key is <em>not</em> pressed, then it is released, so there is no dedicated method to check if a key is released. Just negate the condition by putting a <code>!</code> before the method call.</p>
<h3 id="just-pressed--just-released"><a class="header" href="#just-pressed--just-released">Just Pressed / Just Released</a></h3>
<p>The <code>just_pressed</code> method will let you know if the key was pressed for the first time <em>this</em> frame, which is useful for triggering actions that you only want to happen once per keypress.</p>
<pre><code class="language-rust ignored">if engine.keyboard_state.just_pressed(KeyCode::Escape) {
    // do a thing when the key has just been pressed
}
</code></pre>
<p>Since &quot;just pressed&quot; and &quot;just released&quot; are not logical opposites, there is also a <code>just_released</code> method. This returns <code>true</code> if the key was previously in a pressed state and was just released this frame.</p>
<pre><code class="language-rust ignored">if engine.keyboard_state.just_released(KeyCode::W) {
    // do a thing when the key has just been released
}
</code></pre>
<h3 id="handling-multiple-keys"><a class="header" href="#handling-multiple-keys">Handling Multiple Keys</a></h3>
<p>There is an <code>*_any</code> method for each of the three single key methods that does the same thing, but considering multiple keys at a time. This is especially helpful if you want to, e.g. treat WASD and arrow keys identically.</p>
<ul>
<li><code>pressed</code> -&gt; <code>pressed_any</code></li>
<li><code>just_pressed</code> -&gt; <code>just_pressed_any</code></li>
<li><code>just_released</code> -&gt; <code>just_released_any</code></li>
</ul>
<p>Instead of passing a single <code>KeyCode</code> to these methods, you pass a slice containing all of the key codes you care about:</p>
<pre><code class="language-rust ignored">if engine.keyboard_state.pressed_any(&amp;[KeyCode::W, KeyCode::Up]) {
    // player moves upward
}
if engine.keyboard_state.just_pressed_any(&amp;[KeyCode::Q, KeyCode::F1]) {
    // open menu
}
if engine.keyboard_state.just_released_any(&amp;[KeyCode::Space, KeyCode::LControl]) {
    // reevaluate your life choices
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h1>
<p>Keyboard events are what your operating system passes to text input boxes. If you go to a text box in a browser and hold down the space bar, you'll typically see one space, a short pause, and then several spaces come out faster after that. Those are keyboard events. You typically <em>only</em> want keyboard events if you are trying to capture sequences of keypresses as if they are text. For things like character movement and button presses where you only care about the final state of the keyboard each frame, you should check out the <a href="105-keyboard-state.html">Keyboard State</a> section instead.</p>
<p>Keyboard events are passed through from Bevy as instances of the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> struct. Here is an example of processing keyboard events to adjust the position of a sprite:</p>
<pre><code class="language-rust ignored">for keyboard_event in game_state.keyboard_events.drain(..) {
    // We're using `if let` and a pattern to both destructure the struct and at the
    // same time match &quot;Pressed&quot; events containing some key code.
    if let KeyboardInput {
        scan_code: _,
        key_code: Some(key_code),
        state: ElementState::Pressed,
    } = keyboard_event
    {
        match key_code {
            KeyCode::W | KeyCode::Up =&gt; race_car.translation.y += 10.0,
            KeyCode::A | KeyCode::Left =&gt; race_car.translation.x -= 10.0,
            KeyCode::S | KeyCode::Down =&gt; race_car.translation.y -= 10.0,
            KeyCode::D | KeyCode::Right =&gt; race_car.translation.x += 10.0,
            _ =&gt; {}
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse-state"><a class="header" href="#mouse-state">Mouse State</a></h1>
<p>Everything said about the <a href="105-keyboard-state.html">Keyboard State</a> is true for Mouse State as well, just for your mouse instead of your keyboard. Mouse state is perfect for character movement or game controls such as buttons. If you need to process every bit of mouse input, such as all the locations the mouse was in since the beginning of the last frame, then you'll need to look at <a href="120-mouse-events.html">Mouse Events</a> instead.</p>
<p>All mouse state is stored in the <code>Engine.mouse_state</code>, and queried via methods.</p>
<h3 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h3>
<p>Mouse button handling closely parallels <a href="105-keyboard-state.html">keyboard state handling</a>, with the same six methods. Only instead of accepting <code>KeyCode</code> variants, they accept <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/enum.MouseButton.html"><code>MouseButton</code></a> variants.</p>
<ul>
<li><code>pressed</code> -&gt; <code>pressed_any</code></li>
<li><code>just_pressed</code> -&gt; <code>just_pressed_any</code></li>
<li><code>just_released</code> -&gt; <code>just_released_any</code></li>
</ul>
<p>Rather than repeat the entire discussion for each of the six methods, here's a quick example covering them all:</p>
<pre><code class="language-rust ignored">if engine.mouse_state.pressed(MouseButton::Left) {
    // The left mousebutton is currently pressed -- process some continuous movement
}
if engine.mouse_state.just_pressed(MouseButton::Right) {
    // click that button!
}
if engine.mouse_state.just_released(MouseButton::Right) {
    // nope, unclick the button.
}
if engine.mouse_state.pressed_any(&amp;[MouseButton::Left, MouseButton::Right]) {
    // one or more of the main mouse buttons are currently pressed
}
if engine.mouse_state.just_pressed_any(&amp;[MouseButton::Middle, MouseButton::Other(4)]) {
    // the middle button or the 4th button (or both) was just pressed
}
if engine.mouse_state.just_released_any(&amp;[MouseButton::Left, MouseButton::Middle]) {
    // one of those buttons was just released
}
</code></pre>
<h3 id="location"><a class="header" href="#location">Location</a></h3>
<p>Use the <code>location</code> method to see where the mouse is. It returns an <code>Option&lt;Vec2&gt;</code>. If <code>None</code> is returned, then the mouse pointer isn't in the window. If present, the <code>Vec2</code> value is in the same 2D world coordinate system as the rest of the game. See the <a href="60-sprite-placement.html">section on sprite translation</a> for more info about <code>Vec2</code> or the world coordinate system.</p>
<p>It is easy to demonstrate <code>location</code> by having a sprite appear wherever your mouse is located:</p>
<pre><code class="language-rust ignored">// `player` is a sprite
if let Some(location) = engine.mouse_state.location() {
    player.translation = location;
}
</code></pre>
<h3 id="motion"><a class="header" href="#motion">Motion</a></h3>
<p>The relative motion that the mouse moved last frame is accumulated into a single <code>Vec2</code>. This could be useful if you want to base some logic over how fast or in which direction the mouse is moving.</p>
<pre><code class="language-rust ignored">let motion = engine.mouse_state.motion();
if motion.length() &gt; 50.0 {
    // mouse is moving pretty fast
}
</code></pre>
<h3 id="mouse-wheel"><a class="header" href="#mouse-wheel">Mouse Wheel</a></h3>
<p>This represents both the final scrolling (vertical, y) state of the mouse wheel and the final tilt (horizontal, x) state of the mouse wheel. See the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/struct.MouseWheelState.html"><code>MouseWheelState</code> docs</a> for more info on that.</p>
<pre><code class="language-rust ignored">let mouse_wheel_state = engine.mouse_state.wheel();
if mouse_wheel_state.y &gt; 0 {
    // scrolling in one direction...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse-events"><a class="header" href="#mouse-events">Mouse Events</a></h1>
<p>Every movement of the mouse, click of a mouse button, or scrolling tick of a scroll wheel generates a mouse event. All of the mouse events are stored into a set of vectors on <code>Engine</code> that can be examined. At the end of each frame, any unprocessed events are thrown away.</p>
<p>Mouse events are most useful when you want to process multiple events that happened within a single frame, such as processing all of the points that a mouse traversed, or all of the mousewheel clicks that happened in a single frame.</p>
<h3 id="mouse-button-events"><a class="header" href="#mouse-button-events">Mouse button events</a></h3>
<p>You usually want to use <a href="115-mouse-state.html">mouse state</a> for mouse buttons, which are less awkward to deal with than mouse events when you only care about the state the mouse ended up in at the end of the frame. Mouse events are available in the <code>Engine.mouse_button_events</code> vector. The Bevy struct <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a> is used for the event value.  Here is an example of using mouse button events to rotate a sprite by a fixed amount for each click. This is guaranteed not to miss any clicks in the (unlikely) event that two clicks come in on the same frame.</p>
<pre><code class="language-rust ignored">for mouse_button_input in &amp;engine.mouse_button_events {
    if mouse_button_input.state != ElementState::Pressed {
        break;
    }
    match mouse_button_input.button {
        MouseButton::Left =&gt; sprite.rotation += std::f32::consts::FRAC_PI_4,
        MouseButton::Right =&gt; sprite.rotation -= std::f32::consts::FRAC_PI_4,
        _ =&gt; {}
    }
}
</code></pre>
<h3 id="mouse-location-events"><a class="header" href="#mouse-location-events">Mouse location events</a></h3>
<p>Mouse location events are most useful if you are trying to capture all the points the mouse was at during the frame. Unlike mouse button events, there are <em>often</em> multiple mouse location events, since moving the mouse produces a series of events for each location that the mouse cursor is rendered on screen. If you only care about the final location of the mouse during the frame, you should use <a href="115-mouse-state.html">mouse state</a> instead.</p>
<p>Mouse location events are accessed through the <code>Engine.mouse_location_events</code> vector and contain the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/struct.CursorMoved.html"><code>CursorMoved</code></a> struct re-exported from Bevy. If one wanted to draw a trail of sparkles wherever a mouse went, mouse location events might be a good source of data:</p>
<pre><code class="language-rust ignored">for cursor_moved in &amp;engine.mouse_location_events {
    // draw sparkles at cursor_moved.position
}
</code></pre>
<h3 id="mouse-motion-events"><a class="header" href="#mouse-motion-events">Mouse motion events</a></h3>
<p>Each location event has a corresponding motion event which reports the <em>relative</em> motion of the mouse, rather than the absolute location.  Mouse motion events are accessed through the <code>Engine.mouse_motion_events</code> vector and contain the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a> struct re-exported from Bevy.</p>
<pre><code class="language-rust ignored">for mouse_motion in &amp;engine.state.mouse_motion_events {
    // do something with mouse_motion.delta
}
</code></pre>
<h3 id="mouse-wheel-events"><a class="header" href="#mouse-wheel-events">Mouse wheel events</a></h3>
<p>As the mouse wheel tends to produce multiple events in a single frame, mouse wheel events may tend to be more useful than the mouse wheel state. Mouse wheel events are accessed through the <code>Engine.mouse_wheel_events</code> vector and contain the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a> struct re-exported from Bevy. Here's an example of using the mouse wheel to scale the size of a sprite up or down. The <code>y</code> field represents the turning of the wheel. The <code>x</code> field represents sideways tilting motion for mouse wheels that support it.</p>
<pre><code class="language-rust ignored">for mouse_wheel in &amp;engine.mouse_wheel_events {
    sprite.scale *= 1.0 + (0.05 * mouse_wheel.y);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text in Rusty Engine is a lot like sprites. It has the same set of translation, rotation, scale, and layer fields. It is placed using the same world coordinate system as sprites. (Indeed, Rusty Engine went to great pains to use the same coordinate system for <em>everything</em>: rather than having separate coordinate systems for world and screen space, there is only world space.) Only instead of being based on a rectangular image file, text is based on a string value combined with a font and font size which are used to generate an image at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-creation"><a class="header" href="#text-creation">Text Creation</a></h1>
<p>Text creation is quite similar to sprite creation. You create text through the <a href="400-engine.html"><code>Engine.add_text</code></a> method.  Since <code>Game</code> implements <code>DerefMut&lt;Engine&gt;</code>, you can also call all of <code>Engine</code>'s creation methods through <code>Game</code> in your <code>main()</code> function. In either case, it looks something like this when you create text:</p>
<pre><code class="language-rust ignored">// Through your `Game` in `main()`
let _ = game.add_text(&quot;title&quot;, &quot;The Fun Game&quot;);

// Or later in a game logic function through the `Engine`
let _ = engine.add_text(&quot;score&quot;, &quot;Score: 0&quot;);
</code></pre>
<p>The first parameter is a unique label. It is used in the same way as sprite labels are used (to identify the text later on). The second parameter is actual string value to render.</p>
<p><code>add_text</code> returns a mutable reference to a <code>Text</code> (<code>&amp;mut Text</code>). Note that this is one case where Rusty Engine does <em>not</em> re-export something from Bevy. Bevy has also has a struct named <code>Text</code>, but it is entirely a different thing.</p>
<p>Since it will emit a warning to silently ignore the mutable reference to the <code>Text</code>, you should explicitly ignore it if you are not going to use it by doing <code>let _ = ...</code> as in the examples above. However, most of the time you will want to use the mutable reference to immediately adjust your text, as we'll see in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-value-font--font-size"><a class="header" href="#text-value-font--font-size">Text Value, Font &amp; Font Size</a></h1>
<p>Changing the string value, the chosen font, or the font size causes the <code>Text</code> to be re-rendered as a new image at the end of the frame. This is relatively expensive in terms of performance, so you should avoid changing these attributes except when you actually need to.</p>
<p>All existing text values can be accessed through the <code>Engine.texts</code> vector.</p>
<h3 id="value"><a class="header" href="#value">Value</a></h3>
<p><code>Text.value</code> is the actual string that gets rendered to the screen. If you change the value, then the <code>Text</code> will be re-rendered as a new image at the end of the frame with the new value.</p>
<pre><code class="language-rust ignored">let score_text = engine.texts.get_mut(&quot;score_text&quot;).unwrap();
score_text.value = format!(&quot;Score: {}&quot;, score);
</code></pre>
<h3 id="font"><a class="header" href="#font">Font</a></h3>
<p>If you change the font, then the <code>Text</code> will be re-rendered as a new image at the end of the frame with the new value.</p>
<p>The asset pack contains two fonts:</p>
<ul>
<li><code>FiraMono-Medium.ttf</code></li>
<li><code>FiraSans-Bold.ttf</code> (the default font if none is specified)</li>
</ul>
<pre><code class="language-rust ignored">let mono = engine.add_text(&quot;mono&quot;, &quot;This text is using a monospace font&quot;);
mono.font = &quot;FiraMono-Medium.ttf&quot;.to_string();
</code></pre>
<p>To use a custom font, place a valid <code>otf</code> or <code>ttf</code> file in <code>assets/font</code> and set it on your <code>Text</code>.</p>
<pre><code class="language-rust ignored">// After placing `party.otf` in the `assets/font/` directory...
let party = engine.add_text(&quot;party&quot;, &quot;Let's Party!&quot;);
mono.font = &quot;party.otf&quot;.to_string();
</code></pre>
<p>If you specify a font file which can't be loaded successfully, you will get an console error like this:</p>
<pre><code class="language-text">Dec 30 15:15:20.624  WARN bevy_asset::asset_server: encountered an error while reading an asset: path not found: /Users/nathan/rust/rusty_engine/assets/font/nonexistent.ttf
</code></pre>
<h3 id="font-size"><a class="header" href="#font-size">Font Size</a></h3>
<p>If you change the font size, then the <code>Text</code> will be re-rendered as a new image at the end of the frame with the font size.</p>
<p>The default font size is <code>30.0</code>. Setting the font size doesn't require a lot of explanation:</p>
<pre><code class="language-rust ignored">let large = engine.add_text(&quot;large&quot;, &quot;This is a large font size!&quot;);
mono.font_size = 96.0;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-placement"><a class="header" href="#text-placement">Text Placement</a></h1>
<p>Text is rendered as an image. This rendering (or re-rendering) happens at the end of the frame after any of the <a href="160-text-attributes.html">Value, Font &amp; Font Size</a> attributes are changed.  However, when values such as translation, rotation, scale, or layer are changed, the image remains the same and its representation on screen is manipulated in the GPU, which is high performance.</p>
<p>In short, feel free to change your text's placement attributes every frame without any big hit in performance.</p>
<h3 id="translation-1"><a class="header" href="#translation-1">Translation</a></h3>
<p><code>Text.translation</code> is a <a href="https://docs.rs/glam/latest/glam/f32/struct.Vec2.html"><code>Vec2</code></a> containing the X and Y coordinates of your text's position on the screen. This <code>Vec2</code> location is in the exact center of the text, both vertically and horizontally. In other words, text is always rendered with &quot;centered&quot; alignment on both axes.</p>
<p>The coordinate system works just like it does in math class. <code>(0.0, 0.0)</code> is in the center of the screen. Positive X goes to the right side of the screen. Positive Y goes to the top of the screen. Every increment of <code>1.0</code> is one logical pixel on the screen. Hi-DPI screens may have more than one physical pixel per logical pixel. See the <a href="400-engine.html"><code>Engine</code></a> section for details on how to check the logical pixel dimensions of your window.</p>
<pre><code class="language-rust ignored">let score_text = game.add_text(&quot;score_text&quot;, &quot;Score: 0&quot;);
score_text.translation = Vec2::new(400.0, -325.0);
</code></pre>
<h3 id="rotation-1"><a class="header" href="#rotation-1">Rotation</a></h3>
<p><code>Text.rotation</code>* is an <code>f32</code> representing the angle in radians from the positive X axis. In other words, a rotation of <code>0.0</code> results in normal, horizontal text along the X axis. A rotation of <code>PI</code> would result in upside-down text.</p>
<p>*Bevy 0.5 does not support text rotation, so modifying this field is currently a no-op. Once Bevy 0.6 is released, and Rusty Engine is updated to use it, this will actually worked as described.</p>
<pre><code class="language-rust ignored">let angled = engine.add_text(&quot;angled&quot;, &quot;This text is at an angle.&quot;);
score_text.rotation = std::f32::consts::PI / 4.0;
</code></pre>
<h3 id="scale-1"><a class="header" href="#scale-1">Scale</a></h3>
<p><code>Text.scale</code>* is an <code>f32</code>. <code>1.0</code> means matching a pixel of the source image to a pixel on the screen. <code>2.0</code> makes the image twice as wide and tall, etc.</p>
<p>Usually, you will want to leave text at a scale of <code>1.0</code>, but if you wish to have text zoom or shrink, modifying the scale has two important advantages compared to changing the font size:</p>
<ul>
<li>Changing the scale is <em>fast</em>. The text image does not need to be re-rendered, and the size change is handled all in GPU hardware.</li>
<li>Changing the scale doesn't cause weird re-rendering inconsistencies, so animating scale changes looks smooth.</li>
</ul>
<p>The main drawback of changing the scale is that since the font is not re-rendered, it looks pixellated when scaled up. Though, this could be considered as a stylistic plus as well.</p>
<p>*Bevy 0.5 does not support changing text scale, so modifying this field is currently a no-op. Once Bevy 0.6 is released, and Rusty Engine is updated to use it, this will actually worked as described.</p>
<pre><code class="language-rust ignored">let zoomed = engine.add_text(&quot;zoomed&quot;, &quot;This text is twice as big as normal.&quot;);
score_text.scale = 2.0;
</code></pre>
<h3 id="layer-1"><a class="header" href="#layer-1">Layer</a></h3>
<p><code>Text.layer</code> is an <code>f32</code> that affects what sprite or text is &quot;on top&quot; of another sprite or text when they overlap. <code>0.0</code> is the default and &quot;bottom&quot; layer, and <code>999.0</code> is the &quot;top&quot; layer. The order of sprites or text on the same layer is random and unstable (can change frame to frame), so you should make sure that sprites and text that will overlap are on different layers. A good practice is to choose a few layers and assign them to constants. For example:</p>
<pre><code class="language-rust ignored">const BACKGROUND_LAYER: f32 = 0.0;
const CHARACTER_LAYER: f32 = 1.0;
const EFFECTS_LAYER: f32 = 2.0;
const UI_BOTTOM_LAYER: f32 = 3.0;
const UI_TOP_LAYER: f32 = 4.0;
</code></pre>
<h3 id="adjusting-your-newly-created-text"><a class="header" href="#adjusting-your-newly-created-text">Adjusting your newly-created text</a></h3>
<p>When you create a <code>Text</code>, you get a mutable reference to the newly-created text that you can use to adjust it.</p>
<pre><code class="language-rust ignored">let text = engine.add_text(&quot;msg&quot;, &quot;This is an important message.&quot;);
text.translation = Vec2::new(0.0, -300.0);
text.layer = UI_TOP_LAYER; // as in previous code snippet
</code></pre>
<p>The <code>Vec2</code> type used for the <code>translation</code> field is from <code>glam</code>, and has <a href="https://docs.rs/glam/latest/glam/f32/struct.Vec2.html">its own documentation</a> you can read up on if you're interested.  The thing you'll probably use the most are its <code>x</code> and <code>y</code> fields. The code below is the same as setting <code>text.translation = Vec2::new(0.0, -300.0);</code></p>
<pre><code class="language-rust ignored">text.translation.x = 0.0;
player.translation.y = -300.0;
</code></pre>
<p>NOTE: If you want to adjust your text's placement smoothly, you will need to multiply your change by the frame's delta value. See the <a href="400-engine.html"><code>Engine</code></a> section for more details.</p>
<h3 id="adjusting-an-existing-text"><a class="header" href="#adjusting-an-existing-text">Adjusting an existing text</a></h3>
<p>To adjust a text which already exists, you need to get a mutable reference to it.  This is where that &quot;label&quot; comes in.  The <code>Engine.texts</code> field is a hash map of labels to texts. You get a mutable reference to a text with the <code>HashMap::get_mut</code> method:</p>
<pre><code class="language-rust ignored">// Be careful with unwrap()! If the entry isn't there, this will crash your game.
let spinning_message = engine.texts.get_mut(&quot;spinning_message&quot;).unwrap();
spinning_message.rotation += TURN_SPEED_PER_SEC * engine.delta_f32;
</code></pre>
<h3 id="deleting-a-text"><a class="header" href="#deleting-a-text">Deleting a text</a></h3>
<p>To delete a text, simply remove it from the <code>Engine.texts</code> hash map.</p>
<pre><code class="language-rust ignored">engine.texts.remove(&quot;old_message&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Rusty Engine has a basic audio system. You can play one looping music track, and quite a few concurrent sound effects.  There are some music and sound effect files included in the asset pack.</p>
<p>Supported audio file formats are <code>ogg</code> (including <code>oga</code>), <code>mp3</code>, <code>flac</code>, and <code>wav</code>.</p>
<p>All audio is accessed through methods on the audio manager accessed through <code>Engine.audio_manager</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="music"><a class="header" href="#music">Music</a></h1>
<p>One music file may be played at a time.  Music always loops repeatedly until explicitly stopped (or the program exits). As with other <code>Engine</code> fields, the audio manager is also available through the <code>Game</code> in your <code>main</code> function:</p>
<h3 id="play"><a class="header" href="#play">Play</a></h3>
<p>The <code>play_music</code> method starts playing looping music. The first parameter should be a <code>MusicPreset</code> enum variant or a music file path relative to <code>assets/audio</code>. All music from the asset pack have variants present in the <code>MusicPreset</code> enum for convenience.</p>
<p>The second parameter is the volume, which should be a value between <code>0.0</code> (silent) and <code>1.0</code> full volume.</p>
<pre><code class="language-rust ignored">// using a preset
game.audio_manager.play_music(MusicPreset::Classy8Bit, 1.0);

// using a filepath relative to `assets/audio`
game.audio_manager.play_music(&quot;music/Classy 8-Bit.oga&quot;, 1.0);
</code></pre>
<p>Any music already playing will be stopped to play a new music selection.</p>
<h3 id="stop"><a class="header" href="#stop">Stop</a></h3>
<p>The <code>stop_music</code> method stops any music that is playing. If no music is playing, it is a no-op.</p>
<pre><code class="language-rust ignored">engine.audio_manager.stop_music();
</code></pre>
<h3 id="music-playing-status"><a class="header" href="#music-playing-status">Music playing status</a></h3>
<p>The <code>music_playing</code> method will return a <code>bool</code> indicating whether or not music is currently playing.</p>
<pre><code class="language-rust ignored">if engine.audio_manager.music_playing() {
    // yep, you remembered to start the music
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-effects"><a class="header" href="#sound-effects">Sound Effects</a></h1>
<p>At least a dozen sound effects can play concurrently. The exact number is probably dependent on the particular hardware you have available on your local machine. Sound effects are played in a &quot;fire and forget&quot; manner, and will each play in a separate channel (if available) and terminate once reaching the end of the audio source.</p>
<h3 id="play-1"><a class="header" href="#play-1">Play</a></h3>
<p>The <code>play_sfx</code> method plays a sound effect. The first parameter should be a <code>SfxPreset</code> enum variant or a music file path relative to <code>assets/audio</code>. All sound effects from the asset pack have variants present in the <code>SfxPreset</code> enum for convenience.</p>
<p>The second parameter is the volume, which should be a value between <code>0.0</code> (silent) and <code>1.0</code> full volume.</p>
<pre><code class="language-rust ignored">// using a preset
engine.audio_manager.play_sfx(SfxPreset::Jingle1, 1.0);

// using a filepath relative to `assets/audio`
engine.audio_manager.play_sfx(&quot;sfx/jingle1.ogg&quot;, 1.0);
</code></pre>
<p>There is no way to interact with sound effects to monitor status or stop them early.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timer"><a class="header" href="#timer">Timer</a></h1>
<p>Rusty Engine re-export's Bevy's <a href="https://docs.rs/rusty_engine/latest/rusty_engine/prelude/struct.Timer.html"><code>Timer</code></a> struct. Please see the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/prelude/struct.Timer.html"><code>Timer</code> API documentation</a> for full details. Below, is a quick introduction to the most vital parts.</p>
<p>Timers are super cheap, performance-wise. Feel free to create them and throw them away as much as you like.</p>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<p>It is easy to create a timer with the <code>from_seconds</code> method. The first parameter is a number of seconds to countdown, and the second parameter is whether or not the timer is repeating. <code>false</code> means the timer will only countdown once, and then remain at <code>0.0</code> once finished. <code>true</code> means the timer will start counting down again from the same countdown time as soon as it has reached <code>0.0</code>.</p>
<pre><code class="language-rust ignored">// A one-shot timer.
let timer_once = Timer::from_seconds(10.0, false);

// A repeating timer.
let timer_repeating = Timer::from_seconds(3.0, true);
</code></pre>
<h3 id="counting-down--finishing"><a class="header" href="#counting-down--finishing">Counting down &amp; Finishing</a></h3>
<p>Timers must be ticked with the <code>tick</code> method to make them actually count down the time. The <code>tick</code> method takes a <code>Duration</code> of time that has gone by, which is exactly what <code>Engine.delta</code> is for.  <code>tick</code> returns an immutable reference to the timer, so you can chain a method call to <code>finished</code> or <code>just_finished</code>.</p>
<pre><code class="language-rust ignored">if timer_once.tick(engine.delta).just_finished() {
    // the one-shot timer just finished, do the thing
}

if timer_repeating.tick(engine.delta).just_finished() {
    // the repeating timer finished (again), do the thing (again)
    // the timer has already begun counting down from the top again at this point
}
</code></pre>
<p>If you don't tick a timer, it is effectively paused.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="engine"><a class="header" href="#engine">Engine</a></h1>
<p>The <code>Engine</code> struct is central to Rusty Engine and has already shown up in many places in this tutorial.  It is highly recommended to read through all of the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/game/struct.Engine.html"><code>Engine</code> API documentation</a>.</p>
<p>Here are a few other tidbits that are worth calling out:</p>
<ul>
<li><code>should_exit</code> - a <code>bool</code> field you can set to <code>true</code> to cause Rusty Engine to cleanly exit at the end of the frame.</li>
<li><code>delta</code> - the duration of the previous frame as a <code>Duration</code>. This should be used for ticking any <code>Timer</code>s.</li>
<li><code>delta_f32</code> - the duration of the previous frame as an <code>f32</code>. This should be used to produce smooth animation. For example, if you define a movement speed in <code>pixels per second</code> such as <code>const MOVE_SPEED: f32 = 50.0</code>, then you can use it to actually move a sprite at that speed by multiplying it by <code>delta_f32</code> like this: <code>sprite.translation.x += MOVE_SPEED * engine.delta_f32</code></li>
<li><code>time_since_startup</code> - the duration since the start of the program as a <code>Duration</code></li>
<li><code>time_since_startup_f64</code> - the duration since the start of the program as an <code>f64</code>. This needs to be a 64-bit float because it would be easy for an <code>f32</code> to reach a number high enough to be low precision. If you want to do math with this number, you should do the math with <code>f64</code>'s, and then convert it to an <code>f32</code> at the very end.</li>
<li><code>window_dimensions</code> - a <code>Vec2</code> describing the width and height of the window in pixels. Since <code>(0.0, 0.0)</code> is the center of the screen, the edges of the screen are +/- <code>window_dimensions / 2.0</code>.</li>
</ul>
<p>...for the rest of the fields (and methods), see the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/game/struct.Engine.html"><code>Engine</code> API documentation</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game"><a class="header" href="#game">Game</a></h1>
<p>The <code>Game</code> struct exists to get your custom game state injected into Bevy, and to serve as a proxy for <code>Engine</code> before the game has started.</p>
<p>Since <code>Game</code> implements <code>DerefMut&lt;Engine&gt;</code>, any field or method not found on <code>Game</code> will be searched for on <code>Engine</code> and used if it is found. So, in a sense, <code>Game</code> is also the <code>Engine</code> while you are setting things up in <code>main</code>. However, there are a couple additional things that are unique to <code>Game</code>:</p>
<h3 id="new"><a class="header" href="#new">New</a></h3>
<p>The first, and most obvious, difference is that <code>Game</code> has a <code>new</code> method, as documented in the <a href="15-init.html">Engine Initialization</a> section. You need to call <code>new</code> in your <code>main</code> function to create a new game. The variable you assign this value to should be mutable.</p>
<pre><code class="language-rust ignored">fn main() {
    let mut game = Game::new();
}
</code></pre>
<h3 id="window-settings"><a class="header" href="#window-settings">Window Settings</a></h3>
<p>Rusty Engine re-exports the <a href="https://docs.rs/rusty_engine/latest/rusty_engine/game/struct.WindowDescriptor.html"><code>WindowDescriptor</code></a> struct from Bevy, whose fields are all used to request certain window attributes. Please be aware that these are only <em>requests</em> for configuration, and that the underlying operating system may refuse (or be unable) to give you exactly what you ask for. For example, you may not be able to obtain a window with larger dimensions than the physical monitor.</p>
<p>Pass a <code>WindowDescriptor</code> to the <code>window_settings</code> method to request specific settings for your game window. This is a great time to take advantage of &quot;struct update&quot; syntax so you don't have to re-specify the fields which you aren't customizing.</p>
<pre><code class="language-rust ignored">game.window_settings(WindowDescriptor {
    title: &quot;My Awesome Game&quot;.into(),
    width: 800.0,
    height: 200.0,
    ..Default::default()
</code></pre>
<h3 id="adding-game-logic-functions"><a class="header" href="#adding-game-logic-functions">Adding Game Logic Functions</a></h3>
<p>Game has an <code>add_logic</code> method to add game logic functions to your game. Please see the <a href="15-init.html">Engine Initialization</a> for more details on this method.</p>
<h3 id="running-the-game"><a class="header" href="#running-the-game">Running the game</a></h3>
<p>The last thing you will do in your main function is to call the <code>run</code> method to begin your game. The <code>run</code> method takes an instance of whatever game state struct you defined, or a unit struct <code>()</code> if you didn't define one.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
